# -*- coding: utf-8 -*-
"""assignment3_template.ipynb adlı not defterinin kopyası

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Azf40kQ6T98UhPXGk0oEtWXMC242UfvM

## BBM 409 - Programming Assignment 3

* You can add as many cells as you want in-between each question.
* Please add comments to your code to explain your work.  
* Please add Markdown cells to answer the (non-coding) questions in the homework text. You can, however, refer to the outputs of code cells without adding them as images to the Markdown cell unless you are requested to do otherwise.
* Please be careful about the order of runs of cells. Doing the homework, it is likely that you will be running the cells in different orders, however, they will be evaluated in the order they appear. Hence, please try running the cells in this order before submission to make sure they work.    
* Please refer to the homework text for any implementation detail. Though you are somewhat expected to abide by the comments in the below cells, they are mainly just provided for guidance. That is, as long as you are not completely off this structure and your work pattern is understandable and traceable, it is fine. For instance, you do not have to implement a particular function within a cell just because the comment directs you to do so.
* This document is also your report. Show your work.

###  Insert personal information (Sezin, Yavuz, 2200356050)

## 1. Implementing a CNN from Scratch (40 points)

### 1.1. Introduction
* Brief overview of the task.
* Answer the questions like, What are the main components of a CNN architecture?, Why we use this in image classification?, etc.
* Description of the dataset used for classification.

Overview of the Task
The task focused on implementing and comparing different deep learning approaches for image classification. Specifically, we explored designing a CNN model from scratch, fine-tuning a pre-trained ResNet18 model, and fine-tuning a pre-trained MobileNetV2 model. The objective was to classify images from the Animal-10 dataset and evaluate the performance of these models in terms of accuracy, precision, recall, F1-score, and other metrics. Through this process, we analyzed the strengths and weaknesses of training from scratch versus transfer learning, gaining insights into practical considerations when choosing between these approaches.

 Main Components of a CNN Architecture:
A CNN (Convolutional Neural Network) is designed specifically for image-related tasks and consists of several key components:

Convolutional Layers: These layers extract important features from images by applying convolutional operations. They help detect patterns such as edges, textures, and more complex shapes as the network deepens.

Activation Functions (ReLU): After the convolutional operation, ReLU is applied to introduce non-linearity, enabling the network to learn complex relationships in the data.

Pooling Layers: Pooling layers, like MaxPooling, reduce the spatial dimensions of feature maps, lowering computational complexity while retaining essential features.

Fully Connected Layers: These layers take the extracted features and connect them to the output classes, mapping the learned features to probabilities or logits.

Dropout: Dropout layers help prevent overfitting by randomly deactivating neurons during training, making the network more robust.

Softmax Layer: This layer is used in classification tasks to normalize the output of the network into probabilities for each class.

These components work together to process raw image data into class predictions efficiently, making CNNs a popular choice for image classification tasks.


CNNs are highly effective for image classification tasks due to their specialized architecture. They are capable of automatically extracting and learning hierarchical features, which range from simple edges to complex patterns. The parameter-sharing property of convolutional layers reduces the total number of trainable parameters, making CNNs more computationally efficient compared to fully connected networks. Pooling layers introduce translation invariance, ensuring robustness to small shifts in the input images. Additionally, CNNs provide a flexible framework that can adapt to a variety of image datasets and consistently achieve high accuracy. Their ability to generalize well, combined with scalability to deep architectures, makes CNNs indispensable in modern computer vision.

the Dataset
The dataset used for this task is Animal-10, which consists of images of 10 different animal classes: dogs, cats, elephants, butterflies, and more. Each class contains 3000 images for training, 750 images for validation, and 750 images for testing. Images were resized to 256x256 pixels and normalized using the mean and standard deviation of ImageNet to ensure compatibility with pre-trained models. To improve model robustness, data augmentation techniques such as random horizontal flipping and rotation were applied during training.

The dataset presents challenges such as class imbalance, inter-class similarity (e.g., between cats and dogs), and variations in image quality, lighting, and perspective. These factors make the Animal-10 dataset a realistic benchmark for testing the performance of deep learning models in image classification tasks. By addressing these challenges, the task allowed for a comprehensive evaluation of the models and their ability to generalize to unseen data.

### 1.2. Data Loading and Preprocessing (3 points)
"""

## Import necessary libraries
!pip install split-folders

import torch
from torchvision import datasets, transforms
from torch.utils.data import DataLoader
from google.colab import drive
import pandas as pd
import torch
from torchvision import datasets, transforms
from torch.utils.data import DataLoader
import os
import splitfolders
from sklearn.model_selection import train_test_split
import shutil
import torch
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim

## Load the dataset using PyTorch's data loading utilities
## Apply necessary preprocessing such as resizing and normalization
## Divide the dataset into training, validation, and testing subsets



"""
# Unmount and remount the drive
drive.flush_and_unmount()
print("Drive unmounted.")

drive.mount('/content/drive', force_remount=True)
print("Drive remounted.")

# Step 1: Set the directory path
data_dir = "/content/drive/MyDrive/Colab Notebooks/pa3_subset_animal"  # Replace with your actual path
print(os.listdir(data_dir))

"""

# Transformation for the training dataset with data augmentation
train_transform = transforms.Compose([
    transforms.RandomHorizontalFlip(p=0.5),            # Randomly flip images horizontally
    transforms.RandomRotation(degrees=15),             # Randomly rotate images by up to 15 degrees
    transforms.RandomResizedCrop(size=(256, 256)),      # Randomly crop and resize to 256x256
    transforms.ColorJitter(brightness=0.2, contrast=0.2, saturation=0.2, hue=0.1),  # Random color jitter
    transforms.ToTensor(),                              # Convert images to PyTorch tensors
    transforms.Normalize(mean=[0.485, 0.456, 0.406],    # Normalize using ImageNet mean and std
                         std=[0.229, 0.224, 0.225])
])

# Transformation for validation and testing datasets (no augmentation)
val_test_transform = transforms.Compose([
    transforms.Resize((256, 256)),                      # Resize images to 256x256
    transforms.ToTensor(),                              # Convert images to PyTorch tensors
    transforms.Normalize(mean=[0.485, 0.456, 0.406],    # Normalize using ImageNet mean and std
                         std=[0.229, 0.224, 0.225])
])

"""
# Step 3: Ensure balanced splitting
output_dir = "/content/drive/MyDrive/Colab Notebooks/balanced_split"
train_dir = os.path.join(output_dir, "train")
val_dir = os.path.join(output_dir, "val")
test_dir = os.path.join(output_dir, "test")

os.makedirs(train_dir, exist_ok=True)
os.makedirs(val_dir, exist_ok=True)
os.makedirs(test_dir, exist_ok=True)

# Split the dataset class-wise into 3000 train, 750 val, and 750 test images
for class_name in os.listdir(data_dir):
    class_dir = os.path.join(data_dir, class_name)
    if not os.path.isdir(class_dir):
        continue

    # Get all images in the class directory
    images = os.listdir(class_dir)
    images = [os.path.join(class_dir, img) for img in images]

    # Balanced split: 300 train, 75 val, 75 test per class
    train_imgs, temp_imgs = train_test_split(images, train_size=300, random_state=42)
    val_imgs, test_imgs = train_test_split(temp_imgs, train_size=75, random_state=42)

    # Create class-specific directories in train, val, and test folders
    os.makedirs(os.path.join(train_dir, class_name), exist_ok=True)
    os.makedirs(os.path.join(val_dir, class_name), exist_ok=True)
    os.makedirs(os.path.join(test_dir, class_name), exist_ok=True)

    # Copy images to their respective directories
    for img_path in train_imgs:
        shutil.copy(img_path, os.path.join(train_dir, class_name))
    for img_path in val_imgs:
        shutil.copy(img_path, os.path.join(val_dir, class_name))
    for img_path in test_imgs:
        shutil.copy(img_path, os.path.join(test_dir, class_name))

print("Balanced dataset split completed!") """

# Mount Google Drive (this step is unavoidable to access your files)
from google.colab import drive
drive.mount('/content/drive', force_remount=True)

import os
from torchvision import datasets, transforms
from torch.utils.data import DataLoader

# Define the directory paths (already pre-split)
train_dir = "/content/drive/MyDrive/Colab Notebooks/balanced_split/train"
val_dir = "/content/drive/MyDrive/Colab Notebooks/balanced_split/val"
test_dir = "/content/drive/MyDrive/Colab Notebooks/balanced_split/test"


# Step 4: Load train, validation, and test datasets using ImageFolder
train_dataset = datasets.ImageFolder(root=train_dir, transform=train_transform)
val_dataset = datasets.ImageFolder(root=val_dir, transform=val_test_transform)
test_dataset = datasets.ImageFolder(root=test_dir, transform=val_test_transform)

# DataLoader settings
batch_size = 32  # Adjust batch size based on your system's GPU memory
train_loader = DataLoader(
    train_dataset,
    batch_size=batch_size,
    shuffle=True,        # Shuffle for training
    num_workers=4,       # Parallel data loading
    pin_memory=True,     # Faster transfer to GPU
    prefetch_factor=2    # Pre-fetch batches to minimize waiting time
)
val_loader = DataLoader(
    val_dataset,
    batch_size=batch_size,
    shuffle=False,       # No shuffling for validation
    num_workers=4,
    pin_memory=True,
    prefetch_factor=2
)
test_loader = DataLoader(
    test_dataset,
    batch_size=batch_size,
    shuffle=False,       # No shuffling for testing
    num_workers=4,
    pin_memory=True,
    prefetch_factor=2
)

# Verify the dataset and DataLoader outputs
print(f"Classes: {train_dataset.classes}")
print(f"Number of training images: {len(train_dataset)}")
print(f"Number of validation images: {len(val_dataset)}")
print(f"Number of test images: {len(test_dataset)}")

# Iterate through one batch to verify DataLoader functionality
for images, labels in train_loader:
    print(f"Batch image shape: {images.shape}")  # Should be (batch_size, 3, 256, 256)
    print(f"Batch labels: {labels}")
    break

"""### 1.3. Define your CNN architecture (7 points)
* Explain the reason behind your architecture.
* Explain your choice of activation functions.

It has an architecture that is well-thought-out to process image data for classification efficiently, using the strengths of Convolutional Neural Networks. This architecture starts with five convolutional layers, each with increased feature channels in a progressive manner (32, 64, 128, 256, 512) to capture hierarchical features. Lower layers are specializing in simple patterns such as edges and textures, while higher layers extract features that become more abstract and complex, like shapes and parts of objects. In order to manage computational complexity and most importantly, to extract only the most relevant spatial features, MaxPooling layers are thrown in after most convolutional layers, reducing the feature maps' spatial dimensions by half:
(256×256 => 128×128). This ensures that the network efficiently condenses information without overwhelming computational resources. A notable choice is skipping MaxPooling after the third convolutional layer, which retains more spatial details at this stage to capture mid-level features before further downsampling.

The three fully-connected layers are placed after the convolutional layers to combine the extracted spatial features into a high-level representation for classification. The first fully connected layer reduces the high-dimensional flattened feature vector (
512×16×16) to 2048 neurons, followed by a second layer refining this down to 1024 neurons. The final fully connected layer maps these learned features to the number of classes for output. This avoid abrupt transformations by gradually reducing the dimensionality and allowing the network to learn relationships between features in a subtile way.

ReLU is used as the activation function for all the layers except the last one, introducing non-linearity in the network without suffering from the vanishing gradient problem that earlier activation functions like Sigmoid and Tanh had. ReLU is computationally efficient and causes sparse activation of neurons, which makes it suitable for deep networks. The last layer doesn't use any activation function because the network outputs logits directly; these are then processed by CrossEntropyLoss during training. This will avoid explicit usage of Softmax and prevents numerical instability that might happen.

Overall, this architecture strikes a balance between feature extraction, computational efficiency, and model capacity. The network is designed to generalize well to complex datasets while avoiding overfitting by progressively reducing spatial dimensions and refining features through convolutional and fully connected layers. Accuracy and efficiency are well ensured by the deliberate use of activation functions, pooling layers, and a structured reduction of feature dimensions, making it quite fit for image classification tasks.
"""

import torch
import torch.nn as nn
import torch.nn.functional as F

class CNN(nn.Module):

    #Constructor
    def __init__(self, num_classes=10):
        super(CNN, self).__init__()

        # 1. Convolutional Layer + ReLU + Max Pooling
        self.conv1 = nn.Conv2d(in_channels=3, out_channels=32, kernel_size=3, stride=1, padding=1)  # Output: 32x256x256
        self.pool1 = nn.MaxPool2d(kernel_size=2, stride=2)  # Output: 32x128x128

        # 2. Convolutional Layer + ReLU + Max Pooling
        self.conv2 = nn.Conv2d(in_channels=32, out_channels=64, kernel_size=3, stride=1, padding=1)  # Output: 64x128x128
        self.pool2 = nn.MaxPool2d(kernel_size=2, stride=2)  # Output: 64x64x64

        # 3. Convolutional Layer + ReLU
        self.conv3 = nn.Conv2d(in_channels=64, out_channels=128, kernel_size=3, stride=1, padding=1)  # Output: 128x64x64

        # 4. Convolutional Layer + ReLU + Max Pooling
        self.conv4 = nn.Conv2d(in_channels=128, out_channels=256, kernel_size=3, stride=1, padding=1)  # Output: 256x64x64
        self.pool4 = nn.MaxPool2d(kernel_size=2, stride=2)  # Output: 256x32x32

        # 5. Convolutional Layer + ReLU + Max Pooling
        self.conv5 = nn.Conv2d(in_channels=256, out_channels=512, kernel_size=3, stride=1, padding=1)  # Output: 512x32x32
        self.pool5 = nn.MaxPool2d(kernel_size=2, stride=2)  # Output: 512x16x16

        # Fully Connected Layers
        self.fc1 = nn.Linear(512 * 16 * 16, 2048)  # First fully connected layer
        self.dropout1 = nn.Dropout(p=0.5)          # Dropout after the first FC layer

        self.fc2 = nn.Linear(2048, num_classes)    # Second fully connected layer

    def forward(self, x):
        # Pass through the convolutional layers with ReLU and pooling
        x = F.relu(self.conv1(x))
        x = self.pool1(x)

        x = F.relu(self.conv2(x))
        x = self.pool2(x)

        x = F.relu(self.conv3(x))

        x = F.relu(self.conv4(x))
        x = self.pool4(x)

        x = F.relu(self.conv5(x))
        x = self.pool5(x)

        # Flatten the output from the convolutional layers
        x = torch.flatten(x, 1)

        #  fully connected layers with Dropout
        x = F.relu(self.fc1(x))
        x = self.dropout1(x)
        x = self.fc2(x)

        return x

"""### 1.4 Prepare the model for training (3 points)
* Explain your choice of loss functions and optimization algorithms.
"""

## Define appropriate loss function for multi-class classification (e.g., cross-entropy loss)
!pip install torchsummary
from torchsummary import summary
num_classes = 10
model = CNN(num_classes=num_classes)

criterion = nn.CrossEntropyLoss()

#model is on the CPU
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
model.to(device) # Move model to the correct device before calling summary

summary(model, (3, 256, 256))

## Choose an optimizer (SGD or Adam) and set its parameters (e.g., learning rate)
optimizer = optim.Adam(
    model.parameters(),
    lr=0.0001,
    weight_decay=1e-3    # L2 regularization
)

"""### 1.5 Train and Validate the CNN model (9 points)"""

import torch.optim as optim
from torch.utils.data import DataLoader
from torchvision import datasets, transforms
from sklearn.model_selection import train_test_split
import shutil
from tqdm import tqdm
from torch.cuda.amp import autocast, GradScaler
import matplotlib.pyplot as plt

num_epochs = 150

# Lists to store metrics
train_losses, val_losses = [], []
train_accuracies, val_accuracies = [], []

for epoch in range(num_epochs):
    print(f"Epoch {epoch + 1}/{num_epochs}")
    print("-" * 30)

    # Training
    model.train()
    train_loss = 0
    correct = 0
    total = 0
    for images, labels in tqdm(train_loader):
        images, labels = images.to(device), labels.to(device)
        optimizer.zero_grad()
        outputs = model(images)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()
        train_loss += loss.item() * images.size(0)
        _, predicted = outputs.max(1)
        total += labels.size(0)
        correct += predicted.eq(labels).sum().item()

    train_loss /= len(train_loader.dataset)
    train_accuracy = 100.0 * correct / total
    train_losses.append(train_loss)
    train_accuracies.append(train_accuracy)
    print(f"Training Loss: {train_loss:.4f}, Training Accuracy: {train_accuracy:.2f}%")

    # Validation
    model.eval()
    val_loss = 0
    correct = 0
    total = 0
    with torch.no_grad():
        for images, labels in tqdm(val_loader):
            images, labels = images.to(device), labels.to(device)
            outputs = model(images)
            loss = criterion(outputs, labels)
            val_loss += loss.item() * images.size(0)
            _, predicted = outputs.max(1)
            total += labels.size(0)
            correct += predicted.eq(labels).sum().item()

    val_loss /= len(val_loader.dataset)
    val_accuracy = 100.0 * correct / total
    val_losses.append(val_loss)
    val_accuracies.append(val_accuracy)
    print(f"Validation Loss: {val_loss:.4f}, Validation Accuracy: {val_accuracy:.2f}%")

# Save the model
torch.save(model.state_dict(), '/content/drive/MyDrive/CNN_model.pth')

## You can conduct experiments with different hyperparameters to get the best performing model, considering you will be uploading your best model into Kaggle for compitation :)

"""Training Hyperparameters:

>>Training Loss: 2.3039, Training Accuracy: 9.43%

>>Validation Loss: 2.3027, Validation Accuracy: 10.00%

Optimizer Type: Adam Optimizer.

Learning Rate (lr): 0.001

Number of Epochs30

Batch Size:32

Loss Function:CrossEntropyLoss for multi-class classification tasks.

Dropout : (0.5)

3 fully connected layer



Training Hyperparameters:

>>Training Loss: 0.0001, Training Accuracy: 100.00%

>>Validation Loss: 4.3032, Validation Accuracy: 40.80%


Optimizer Type: SGD Optimizer.

Learning Rate (lr): 0.01

Number of Epochs :30

Batch Size:32

Loss Function:CrossEntropyLoss for multi-class classification tasks.

Dropout : --

2 fully connected layer



Training Hyperparameters:

>>Training Loss: 0.0001, Training Accuracy:98.20%

>>Validation Loss: 4.3032, Validation Accuracy: 38.27%


Optimizer Type: Adam Optimizer.

Learning Rate (lr): 0.001

Number of Epochs :150

Batch Size:32

Loss Function:CrossEntropyLoss for multi-class classification tasks.

Dropout : --

2 fully connected layer

Training Hyperparameters:

>>Training Loss: 0.0001, Training Accuracy:97.50%


>>Validation Loss: 4.3032, Validation Accuracy:46.80%


Optimizer Type: Adam Optimizer.

Learning Rate (lr): 0.0001

Number of Epochs :30

Batch Size:32

Loss Function:CrossEntropyLoss for multi-class classification tasks.

Dropout : --

2 fully connected layer



Training Hyperparameters:

>>Training Loss: 0.0001, Training Accuracy:66.77%

>>Validation Loss: 1.0092, Validation Accuracy: 64.40%




Optimizer Type: Adam Optimizer.

Learning Rate (lr): 0.0001

Number of Epochs :150


Batch Size:32

Loss Function:CrossEntropyLoss for multi-class classification tasks.

Dropout : --

2 fully connected layer

Learning Rate: The learning rate is a critical hyperparameter in training deep learning models as it determines how much the weights are updated during each optimization step. For the experiments, I chose:

A learning rate of 0.001 for Adam optimizer: This value is a widely accepted default for Adam due to its ability to adaptively adjust the learning rate for each parameter during training. It balances convergence speed and stability.
A learning rate of 0.01 for SGD optimizer: A slightly higher learning rate for SGD was selected as it does not adaptively adjust the learning rate like Adam, and starting with a higher value accelerates convergence in the initial stages.
Batch Size: The batch size of 32 was chosen for all experiments as it strikes a balance between computational efficiency and model performance:

Smaller batch sizes (like 16) can introduce more noise in gradient estimation, leading to less stable training.
Larger batch sizes (like 64 or 128) might lead to overfitting, as the model might converge to sharper minima that generalize poorly.
Batch size 32 ensures effective memory utilization while providing sufficient gradient stability for better optimization.
"""

## Select your best model with respect to validation accuracy
## Visualize the accuracy and loss change of the best performing model across training and validation datasets.
# Plot training and validation loss
from sklearn.metrics import classification_report, confusion_matrix
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np

# Plot metrics
plt.figure(figsize=(12, 5))
plt.plot(train_losses, label='Training Loss')
plt.plot(val_losses, label='Validation Loss')
plt.title('Loss Across Epochs')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.legend()
plt.show()

plt.figure(figsize=(12, 5))
plt.plot(train_accuracies, label='Training Accuracy')
plt.plot(val_accuracies, label='Validation Accuracy')
plt.title('Accuracy Across Epochs')
plt.xlabel('Epoch')
plt.ylabel('Accuracy (%)')
plt.legend()
plt.show()

"""### 1.6 Evaluate the trained model on the test set (6 points)"""

## Test the trained model on the test set to evaluate its performance
## Compute metrics such as accuracy, precision, recall, and F1-score
## Visualize confusion matrix to understand the model's behavior across different classes
## Comment on the results

import torch
from sklearn.metrics import classification_report, confusion_matrix
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np

model.eval()

# Test the model
all_preds = []
all_labels = []
with torch.no_grad():
    for images, labels in test_loader:
        images, labels = images.to(device), labels.to(device)
        outputs = model(images)
        _, predicted = outputs.max(1)
        all_preds.extend(predicted.cpu().numpy())
        all_labels.extend(labels.cpu().numpy())

# Compute accuracy
accuracy = np.mean(np.array(all_preds) == np.array(all_labels))
print(f"Test Accuracy: {accuracy * 100:.2f}%")

# Classification Report
class_names = test_dataset.classes
report = classification_report(all_labels, all_preds, target_names=class_names)
print("Classification Report:\n")
print(report)

# Confusion Matrix
cm = confusion_matrix(all_labels, all_preds)

# Plot Confusion Matrix
plt.figure(figsize=(10, 8))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=class_names, yticklabels=class_names)
plt.xlabel('Predicted')
plt.ylabel('True')
plt.title('Confusion Matrix')
plt.show()

"""### 1.7 Conclusion and interpretation (7 points)
* Summarize the performance of the model on the test set
* Discuss any challenges encountered during training and potential areas for improvement
* Reflect on the overall effectiveness of the chosen CNN architecture and training approach

The CNN model performed moderately well on the test set, achieving an accuracy of 64.93%. While the overall performance was balanced with a macro-average F1-score of 65%, there were notable disparities between classes. For instance, the model classified "Farfalla" (butterfly) and "Ragno" (spider) effectively, achieving F1-scores of 0.79 and 0.76, respectively. However, it struggled with classes like "Mucca" (cow) and "Cane" (dog), which had lower F1-scores of 0.57 and 0.42. This suggests that the model was unable to effectively learn distinguishing features for some classes, possibly due to the dataset's complexity or limitations in feature extraction.

Several challenges were encountered during training. Overfitting was a significant issue, likely because the dataset, consisting of 4500 images, was relatively small for the complexity of the CNN architecture. The architecture, which included five convolutional layers and a fully connected layer, may have been too complex, leading to a large number of trainable parameters relative to the available data. Although data augmentation was used to improve generalization, it may not have been sufficient to address these challenges fully. Additionally, fine-tuning hyperparameters such as the learning rate, dropout rate, and batch size could have further improved performance.

To improve the model, several steps could be taken. Enhanced data augmentation techniques, such as random zoom, affine transformations, or adding Gaussian noise, could increase dataset diversity and reduce overfitting. Simplifying the model architecture by reducing the number of layers or filters would better align the model complexity with the dataset size. Alternatively, using a pre-trained model through transfer learning (e.g., ResNet or MobileNet) could significantly improve performance by leveraging features learned from larger datasets like ImageNet. Regularization methods, such as increasing the dropout rate or adding weight decay, could also help prevent overfitting. Additionally, strategies such as learning rate scheduling and cross-validation could improve the model's robustness during training.

In summary, the CNN architecture and training approach provided a good starting point, but improvements in data augmentation, model complexity, and training strategies are necessary to achieve better performance and reduce overfitting. These adjustments would enhance the model's ability to generalize and provide more accurate predictions.

### 1.8 Kaggle Test Result (5 points)
* Put your Kaggle test result for your CNN model here and comment on it.
* You will get a score between 0-1 and your percentage (e.g. 0.1, 0.3, 0.6, 0.85) of accuracy will be multiplied by the highest possible score (5 points) for this part. That will be your grading score.

The CNN model achieved an accuracy of 64.3% on the Kaggle test dataset. This indicates that the model is moderately effective in classifying the test images. While the performance is reasonable, it suggests there is room for improvement, particularly in handling challenging or ambiguous classes.

The result reflects the balance between the complexity of the CNN architecture and the size of the dataset. Overfitting may have played a role in limiting the model's generalization, as evidenced by some misclassifications in the validation set during training. To improve this score, additional strategies like enhanced data augmentation, fine-tuning of hyperparameters, and leveraging pre-trained models through transfer learning could be explored.
"""

from torch.utils.data import Dataset, DataLoader
from PIL import Image

# Custom Dataset for test images
class TestDataset(Dataset):
    def __init__(self, image_paths, transform):
        self.image_paths = image_paths
        self.transform = transform

    def __len__(self):
        return len(self.image_paths)

    def __getitem__(self, idx):
        img_path = self.image_paths[idx]
        img = Image.open(img_path).convert('RGB')  # Ensure RGB format
        img = self.transform(img)
        return img, os.path.basename(img_path).split('.')[0]  # Return image and its ID

# Create the test dataset and DataLoader
test_dataset = TestDataset(image_paths=sorted_files, transform=transform)
test_loader = DataLoader(test_dataset, batch_size=32, shuffle=False)

#  Predict class labels for test set images in batches
model = model.to(device)  # Ensure the model is on the correct device
kaggle_preds = []
image_ids = []

with torch.no_grad():
    for images, ids in test_loader:
        images = images.to(device)  # Move images to the GPU
        outputs = model(images)  # Forward pass
        _, predicted = torch.max(outputs, 1)  # Get predicted class indices
        kaggle_preds.extend(predicted.cpu().numpy())  # Move predictions to CPU and store
        image_ids.extend(ids)  # Store image IDs

#  Map predicted class indices to class labels
predicted_labels = [class_names[pred] for pred in kaggle_preds]

# Save predictions to CSV file
submission = pd.DataFrame({'ID': image_ids, 'Label': predicted_labels})
submission.to_csv('/content/predictions.csv', index=False)
print("Submission file saved as 'predictions.csv'")

# Download
from google.colab import files
files.download('/content/predictions.csv')

"""## 2. Exploring Transfer Learning with ResNet50 and MobileNet (60 points)

### 2.1. Introduction
* Brief overview of the task.
* Answer the questions like, What is fine-tuning? Why should we do this? Why do we freeze the rest and train only last layers?

### 2.2. Load the pre-trained ResNet18 model (3 points)
"""

## Utilize torchvision library to load the pre-trained ResNet18 model
## Ensure that the model's architecture matches ResNet18, by checking the model summary.
#Import necessary libraries
from torch import nn
import numpy as np
import torch
import torch.nn.functional as F
import matplotlib.pyplot as plt
from torchvision import datasets, transforms
from  torch import optim
from torchvision import transforms, utils, models

from collections import OrderedDict
device = torch.device('cuda:0' if torch.cuda.is_available() else 'cpu')

"""### 2.3 Modify the ResNet18 model for transfer learning (15 points)"""

## Freeze all layers of the ResNet18 model.
## Replace the final fully connected layer with a new FC layer matching the number of classes
## Unfreeze the final FC layer
## Define appropriate loss function and optimizer for training
## Train the modified ResNet18 model on the animal-10 image dataset. (base model)
# Load the pretrained ResNet18 model
resnet18 = models.resnet18(pretrained=True)
print(resnet18)  # View the architecture to identify layers for modification

# Freeze all layers
for param in resnet18.parameters():
    param.requires_grad = False

# Replace the final fully connected layer
num_features = resnet18.fc.in_features
resnet18.fc = nn.Linear(num_features, 10)

# Unfreeze the FC layer
for param in resnet18.fc.parameters():
    param.requires_grad = True

## Define another ResNet18 model
## Freeze all layers of the ResNet18 model.
## Replace the final fully connected layer with a new FC layer matching the number of classes
## Unfreeze the final FC layer
## Unfreeze convolutional layers 3 and 4 of the ResNet18 model and again proceed with training. (second model)

from torchvision import models
import torch.nn as nn

#  Load the pre-trained ResNet18 model
resnet18_v2 = models.resnet18(pretrained=True)

# Freeze all layers
for param in resnet18_v2.parameters():
    param.requires_grad = False

#  Replace the final fully connected layer
num_classes = 10
resnet18_v2.fc = nn.Linear(resnet18_v2.fc.in_features, num_classes)

#  Unfreeze the final FC layer
for param in resnet18_v2.fc.parameters():
    param.requires_grad = True

#  Unfreeze convolutional layers 3 and 4
for name, param in resnet18_v2.named_parameters():
    if "layer3" in name or "layer4" in name:
        param.requires_grad = True

# Move the model to the appropriate device
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
resnet18_v2 = resnet18_v2.to(device)

## Define another ResNet18 model
## Replace the final fully connected layer with a new FC layer matching the number of classes proceed with training. (third model)
# Load the pre-trained ResNet18 model
resnet18_v3 = models.resnet18(pretrained=True)

# Replace the final fully connected layer with a new one
num_classes = 10
resnet18_v3.fc = nn.Linear(resnet18_v3.fc.in_features, num_classes)

#  Move the model to the appropriate device
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
resnet18_v3 = resnet18_v3.to(device)

## Define appropriate loss function and optimizer for training
## Iterate over the training dataset in mini-batches, compute the loss, and update model parameters.
## Monitor the training process and evaluate all model's performance on the validation set periodically.
## Visualize the accuracy and loss changes of the models across training and validation datasets.

import matplotlib.pyplot as plt
from tqdm import tqdm
import torch.nn as nn
import torch.optim as optim
import torch


# Move all models to the same device
resnet18.to(device)
resnet18_v2.to(device)
resnet18_v3.to(device)
# Define appropriate loss function
criterion = nn.CrossEntropyLoss()

# Define optimizers for all models
optimizer_v1 = optim.Adam(resnet18.parameters(), lr=0.001, weight_decay=1e-4)
optimizer_v2 =  torch.optim.Adam(
    filter(lambda p: p.requires_grad, resnet18_v2.parameters()),  # Only trainable parameters
    lr=0.0001,  # Use a smaller learning rate for fine-tuning
    weight_decay=1e-4
)
optimizer_v3 = optim.Adam(resnet18_v3.parameters(), lr=0.001, weight_decay=1e-4)

# Store metrics for all models
metrics = {
    "resnet18_v1": {"train_losses": [], "val_losses": [], "train_accuracies": [], "val_accuracies": []},
    "resnet18_v2": {"train_losses": [], "val_losses": [], "train_accuracies": [], "val_accuracies": []},
    "resnet18_v3": {"train_losses": [], "val_losses": [], "train_accuracies": [], "val_accuracies": []},
}

# Number of epochs
num_epochs = 30

# Define a function for training and validation
def train_and_validate(model, optimizer, metrics_key):
    for epoch in range(num_epochs):
        print(f"Model: {metrics_key} | Epoch {epoch + 1}/{num_epochs}")
        print("-" * 30)

        # Training Phase
        model.train()
        train_loss = 0
        correct = 0
        total = 0
        for images, labels in tqdm(train_loader):
            images, labels = images.to(device), labels.to(device)

            optimizer.zero_grad()
            outputs = model(images)
            loss = criterion(outputs, labels)
            loss.backward()
            optimizer.step()

            train_loss += loss.item() * images.size(0)
            _, predicted = outputs.max(1)
            total += labels.size(0)
            correct += predicted.eq(labels).sum().item()

        train_loss /= len(train_loader.dataset)
        train_accuracy = 100.0 * correct / total
        metrics[metrics_key]["train_losses"].append(train_loss)
        metrics[metrics_key]["train_accuracies"].append(train_accuracy)

        print(f"Training Loss: {train_loss:.4f}, Training Accuracy: {train_accuracy:.2f}%")

        # Validation Phase
        model.eval()
        val_loss = 0
        correct = 0
        total = 0
        with torch.no_grad():
            for images, labels in tqdm(val_loader):
                images, labels = images.to(device), labels.to(device)
                outputs = model(images)
                loss = criterion(outputs, labels)

                val_loss += loss.item() * images.size(0)
                _, predicted = outputs.max(1)
                total += labels.size(0)
                correct += predicted.eq(labels).sum().item()

        val_loss /= len(val_loader.dataset)
        val_accuracy = 100.0 * correct / total
        metrics[metrics_key]["val_losses"].append(val_loss)
        metrics[metrics_key]["val_accuracies"].append(val_accuracy)

        print(f"Validation Loss: {val_loss:.4f}, Validation Accuracy: {val_accuracy:.2f}%")

# Train and validate all models
train_and_validate(resnet18, optimizer_v1, "resnet18_v1")
train_and_validate(resnet18_v2, optimizer_v2, "resnet18_v2")
train_and_validate(resnet18_v3, optimizer_v3, "resnet18_v3")

# Visualization of Accuracy and Loss
plt.figure(figsize=(18, 12))

# Accuracy Visualization
plt.subplot(2, 2, 1)
for key in metrics:
    plt.plot(range(1, num_epochs + 1), metrics[key]["train_accuracies"], label=f'{key} - Training')
    plt.plot(range(1, num_epochs + 1), metrics[key]["val_accuracies"], label=f'{key} - Validation')
plt.xlabel('Epochs')
plt.ylabel('Accuracy (%)')
plt.title('Training and Validation Accuracy')
plt.legend()

# Loss Visualization
plt.subplot(2, 2, 2)
for key in metrics:
    plt.plot(range(1, num_epochs + 1), metrics[key]["train_losses"], label=f'{key} - Training')
    plt.plot(range(1, num_epochs + 1), metrics[key]["val_losses"], label=f'{key} - Validation')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.title('Training and Validation Loss')
plt.legend()

plt.tight_layout()
plt.show()

# Save models
torch.save(resnet18.state_dict(), '/content/drive/MyDrive/ResNet18_v1.pth')
torch.save(resnet18_v2.state_dict(), '/content/drive/MyDrive/ResNet18_v2.pth')
torch.save(resnet18_v3.state_dict(), '/content/drive/MyDrive/ResNet18_v3.pth')

"""Conduct a comparative analysis among these three models. Comment on their performance and select your best model with respect to validation accuracy.
* Which model performed better and why do you think it performed better?  
* Comment on the practical considerations among these models also.

The first ResNet18 model, ResNet18_v1, performed better primarily because of its effective transfer learning approach. This model was initialized with pre-trained weights on ImageNet, hence having a very strong foundation of feature extraction by leveraging knowledge from large and diverse datasets. By freezing all convolutional layers during training, ResNet18_v1 retained these pre-learned features and focused solely on learning task-specific features through the newly added fully connected layer. This approach is especially effective in the case of smaller datasets, when training a deep neural network from scratch might lead to overfitting or suboptimal performance due to insufficient data.

The second model, ResNet18_v2, and the third model, ResNet18_v3, further introduced fine-tuning of more layers, increasing the number of trainable parameters. Fine-tuning, while improving performance on domain-specific datasets that are far from the pre-training data, requires more data and computational resources. In ResNet18_v2, specific layers were unfrozen, such as layers 3 and 4, with the purpose of allowing these layers to adapt to the dataset. The increased flexibility, however, further complicated training and increased the likelihood of overfitting, especially considering that the size of the dataset might be too small to effectively perform fine-tuning. Similarly, ResNet18_v3, which replaced the final fully connected layer and trained all layers without freezing, struggled to keep generalization and stability, further affecting its performance.

From a practical perspective, ResNet18_v1 is extremely efficient for tasks where one needs to deal with limited datasets. This approach reduces computational complexity, as the number of trainable parameters is highly reduced due to frozen layers and so is the training time. At the same time, it avoids overfitting because general features extracted by a pre-trained model have already been very good in most image classification tasks.

By comparison, ResNet18_v2 and ResNet18_v3 would require extensive experimentation in learning rates, regularization techniques, and data augmentation before performing optimally. These are more suitable for situations where the dataset is large or where domain-specific features are very different from those of the pre-trained dataset.

In all, ResNet18_v1 is the best and most practical model for this use case, considering its simplicity and computational efficiency, and its ability to generalize well with limited data. ResNet18_v2 and ResNet18_v3, while more flexible and thus more powerful on domain-specific tasks, did not outperform ResNet18_v1 due to the limited dataset and increased complexity of training.

### 2.4 Evaluate the fine-tuned ResNet18 model (5 points)
"""

## Test the best model on the test set to evaluate its performance.
## Compute metrics such as accuracy, precision, recall, and F1-score to assess classification performance.
## Visualize confusion matrix to understand the model's behavior across different classes
## Comment on the results
## Compare the fine-tuned ResNet18 model performance with the CNN model implemented from scratch
# Ensure the ResNet18 model is in evaluation mode
resnet18.eval()


all_preds_resnet = []
all_labels_resnet = []

# ResNet18 model on the test set
with torch.no_grad():
    for images, labels in test_loader:
        images, labels = images.to(device), labels.to(device)
        outputs = resnet18(images)
        _, predicted = outputs.max(1)
        all_preds_resnet.extend(predicted.cpu().numpy())
        all_labels_resnet.extend(labels.cpu().numpy())

# Compute accuracy for ResNet18
accuracy_resnet = np.mean(np.array(all_preds_resnet) == np.array(all_labels_resnet))
print(f"Test Accuracy (ResNet18): {accuracy_resnet * 100:.2f}%")

# Classification Report for ResNet18
class_names = test_dataset.classes
report_resnet = classification_report(all_labels_resnet, all_preds_resnet, target_names=class_names)
print("\nClassification Report (ResNet18):")
print(report_resnet)

# Confusion Matrix for ResNet18
cm_resnet = confusion_matrix(all_labels_resnet, all_preds_resnet)

# Visualize
plt.figure(figsize=(10, 8))
sns.heatmap(cm_resnet, annot=True, fmt='d', cmap='Blues', xticklabels=class_names, yticklabels=class_names)
plt.xlabel('Predicted')
plt.ylabel('True')
plt.title('Confusion Matrix (ResNet18)')
plt.show()


##CNN
cnn_model = CNN(num_classes=len(class_names))
cnn_model.load_state_dict(torch.load('/content/drive/MyDrive/CNN_model.pth'))  # Load the CNN model
cnn_model.to(device)
cnn_model.eval()

all_preds_cnn = []
all_labels_cnn = []

# Evaluate the CNN model on the test set
with torch.no_grad():
    for images, labels in test_loader:
        images, labels = images.to(device), labels.to(device)
        outputs = cnn_model(images)
        _, predicted = outputs.max(1)
        all_preds_cnn.extend(predicted.cpu().numpy())
        all_labels_cnn.extend(labels.cpu().numpy())

# Compute accuracy for CNN
accuracy_cnn = np.mean(np.array(all_preds_cnn) == np.array(all_labels_cnn))
print(f"Test Accuracy (CNN): {accuracy_cnn * 100:.2f}%")

# Classification Report for CNN
report_cnn = classification_report(all_labels_cnn, all_preds_cnn, target_names=class_names)
print("\nClassification Report (CNN):")
print(report_cnn)

# Confusion Matrix for CNN
cm_cnn = confusion_matrix(all_labels_cnn, all_preds_cnn)

# Visualize confusion matrix for CNN
plt.figure(figsize=(10, 8))
sns.heatmap(cm_cnn, annot=True, fmt='d', cmap='Greens', xticklabels=class_names, yticklabels=class_names)
plt.xlabel('Predicted')
plt.ylabel('True')
plt.title('Confusion Matrix (CNN)')
plt.show()


print("\nComparison of Results:")
print(f"ResNet18 Test Accuracy: {accuracy_resnet * 100:.2f}%")
print(f"CNN Test Accuracy: {accuracy_cnn * 100:.2f}%")

"""### 2.5 Kaggle Test Result (5 points)
* Put your Kaggle test result for your ResNet-18 pretrained model here and comment on it.
* You will get a score between 0-1 and your percentage (e.g. 0.1, 0.3, 0.6, 0.85) of accuracy will be multiplied by the highest possible score (5 points) for this part. That will be your grading score.

The ResNet-18 model achieved a remarkable accuracy of 93.0% on the Kaggle test dataset. This result demonstrates the effectiveness of leveraging a pre-trained model like ResNet-18, which has already learned robust feature representations from large datasets such as ImageNet. The high accuracy indicates that the fine-tuning process successfully adapted the model to the specific classification task.

The performance improvement compared to the custom CNN model is significant, highlighting the advantages of transfer learning over training a model from scratch, especially when working with relatively small datasets. The ResNet-18 model's deeper architecture and pre-trained weights allowed it to generalize better and achieve higher accuracy on unseen dat
"""

from torch.utils.data import Dataset, DataLoader
from PIL import Image

# Custom Dataset for test images
class TestDataset(Dataset):
    def __init__(self, image_paths, transform):
        self.image_paths = image_paths
        self.transform = transform

    def __len__(self):
        return len(self.image_paths)

    def __getitem__(self, idx):
        img_path = self.image_paths[idx]
        img = Image.open(img_path).convert('RGB')  # Ensure RGB format
        img = self.transform(img)
        return img, os.path.basename(img_path).split('.')[0]  # Return image and its ID

# Create the test dataset and DataLoader
test_dataset = TestDataset(image_paths=sorted_files, transform=transform)
test_loader = DataLoader(test_dataset, batch_size=32, shuffle=False)

#  Predict class labels for test set images in batches
model = resnet18.to(device)  # Ensure the model is on the correct device
kaggle_preds = []
image_ids = []

with torch.no_grad():
    for images, ids in test_loader:
        images = images.to(device)  # Move images to the GPU
        outputs = model(images)  # Forward pass
        _, predicted = torch.max(outputs, 1)  # Get predicted class indices
        kaggle_preds.extend(predicted.cpu().numpy())  # Move predictions to CPU and store
        image_ids.extend(ids)  # Store image IDs

#  Map predicted class indices to class labels
predicted_labels = [class_names[pred] for pred in kaggle_preds]

# Save predictions to CSV file
submission = pd.DataFrame({'ID': image_ids, 'Label': predicted_labels})
submission.to_csv('/content/predictions.csv', index=False)
print("Submission file saved as 'predictions.csv'")

# Download
from google.colab import files
files.download('/content/predictions.csv')

"""### 2.7. Load the pre-trained MobileNet model (3 points)

"""

## Utilize torchvision library to load the pre-trained MobileNetV2 model
## Ensure that the model's architecture matches MobileNetV2, by checking the model summary.


import torch
from torchvision import models
from torchsummary import summary

# Define the device
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

# Load the pre-trained MobileNetV2 model
mobilenet_v2 = models.mobilenet_v2(pretrained=True)

# Move the model
mobilenet_v2 = mobilenet_v2.to(device)

#  model architecture
print("MobileNetV2 Model Architecture:")
print(mobilenet_v2)

# Check the model summary

print("\nModel Summary:")
summary(mobilenet_v2, (3, 224, 224))

"""### 2.8 Modify the MobileNet model for transfer learning (10 points)"""

## Freeze all layers of the MobileNet model.
## Replace the final fully connected layer with a new FC layer matching the number of classes
## Unfreeze the final FC layer
## Define appropriate loss function and optimizer for training
## Train the modified MobileNet model on the animal-10 image dataset. (base model)


import torch
from torch import nn
from torchvision import models
from torch.optim import Adam
from tqdm import tqdm
# Freeze all layers
for param in mobilenet_v2.features.parameters():
    param.requires_grad = False

# Replace the final fully connected layer

num_classes = 10
mobilenet_v2.classifier[1] = nn.Linear(mobilenet_v2.last_channel, num_classes)

# Unfreeze the final FC layer
for param in mobilenet_v2.classifier.parameters():
    param.requires_grad = True

# Move the model to the device
mobilenet_v2 = mobilenet_v2.to(device)

## Define another MobileNet model
## Replace the final fully connected layer with a new FC layer matching the number of classes proceed with training. (second model)

# Define the device
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

# Load the pre-trained MobileNetV2 model
mobilenet_v2_v2 = models.mobilenet_v2(pretrained=True)

# Replace the final fully connected layer
num_classes = 10
mobilenet_v2_v2.classifier[1] = nn.Linear(mobilenet_v2_v2.last_channel, num_classes)


for param in mobilenet_v2_v2.classifier.parameters():
    param.requires_grad = True

# Move the model to the device
mobilenet_v2_v2 = mobilenet_v2_v2.to(device)

## Define appropriate loss function and optimizer for training
## Iterate over the training dataset in mini-batches, compute the loss, and update model parameters.
## Monitor the training process and evaluate all model's performance on the validation set periodically.
## Visualize the accuracy and loss changes of the models across training and validation datasets.

import matplotlib.pyplot as plt
from tqdm import tqdm
import torch.nn as nn
import torch.optim as optim
import torch

#  the loss function
criterion = nn.CrossEntropyLoss()

#  optimizers for all models
optimizer_v1 = optim.Adam(mobilenet_v2.parameters(), lr=0.001, weight_decay=1e-4)  # First MobileNetV2 model
optimizer_v2 = optim.Adam(mobilenet_v2_v2.parameters(), lr=0.001, weight_decay=1e-4)  # Second MobileNetV2 model


metrics = {
    "mobilenet_v2_v1": {"train_losses": [], "val_losses": [], "train_accuracies": [], "val_accuracies": []},
    "mobilenet_v2_v2": {"train_losses": [], "val_losses": [], "train_accuracies": [], "val_accuracies": []},
}

# Number of epochs
num_epochs = 30

# function for training and validation
def train_and_validate(model, optimizer, metrics_key):
    for epoch in range(num_epochs):
        print(f"Model: {metrics_key} | Epoch {epoch + 1}/{num_epochs}")
        print("-" * 30)


        model.train()
        train_loss = 0
        correct = 0
        total = 0
        for images, labels in tqdm(train_loader):
            images, labels = images.to(device), labels.to(device)

            optimizer.zero_grad()
            outputs = model(images)
            loss = criterion(outputs, labels)
            loss.backward()
            optimizer.step()

            train_loss += loss.item() * images.size(0)
            _, predicted = outputs.max(1)
            total += labels.size(0)
            correct += predicted.eq(labels).sum().item()

        train_loss /= len(train_loader.dataset)
        train_accuracy = 100.0 * correct / total
        metrics[metrics_key]["train_losses"].append(train_loss)
        metrics[metrics_key]["train_accuracies"].append(train_accuracy)

        print(f"Training Loss: {train_loss:.4f}, Training Accuracy: {train_accuracy:.2f}%")

        # Validation
        model.eval()
        val_loss = 0
        correct = 0
        total = 0
        with torch.no_grad():
            for images, labels in tqdm(val_loader):
                images, labels = images.to(device), labels.to(device)
                outputs = model(images)
                loss = criterion(outputs, labels)

                val_loss += loss.item() * images.size(0)
                _, predicted = outputs.max(1)
                total += labels.size(0)
                correct += predicted.eq(labels).sum().item()

        val_loss /= len(val_loader.dataset)
        val_accuracy = 100.0 * correct / total
        metrics[metrics_key]["val_losses"].append(val_loss)
        metrics[metrics_key]["val_accuracies"].append(val_accuracy)

        print(f"Validation Loss: {val_loss:.4f}, Validation Accuracy: {val_accuracy:.2f}%")

# Train and validate all models
train_and_validate(mobilenet_v2, optimizer_v1, "mobilenet_v2_v1")
train_and_validate(mobilenet_v2_v2, optimizer_v2, "mobilenet_v2_v2")

# Visualization of Accuracy and Loss
plt.figure(figsize=(18, 12))

# Accuracy
plt.subplot(2, 2, 1)
for key in metrics:
    plt.plot(range(1, num_epochs + 1), metrics[key]["train_accuracies"], label=f'{key} - Training')
    plt.plot(range(1, num_epochs + 1), metrics[key]["val_accuracies"], label=f'{key} - Validation')
plt.xlabel('Epochs')
plt.ylabel('Accuracy (%)')
plt.title('Training and Validation Accuracy')
plt.legend()

# Loss
plt.subplot(2, 2, 2)
for key in metrics:
    plt.plot(range(1, num_epochs + 1), metrics[key]["train_losses"], label=f'{key} - Training')
    plt.plot(range(1, num_epochs + 1), metrics[key]["val_losses"], label=f'{key} - Validation')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.title('Training and Validation Loss')
plt.legend()

plt.tight_layout()
plt.show()


torch.save(mobilenet_v2.state_dict(), '/content/drive/MyDrive/MobileNetV2_v1.pth')
torch.save(mobilenet_v2_v2.state_dict(), '/content/drive/MyDrive/MobileNetV2_v2.pth')

"""Conduct a comparative analysis among these two models. Comment on their performance and select your best model with respect to validation accuracy.
* Which model performed better and why do you think it performed better?  
* Comment on the practical considerations among these models also.

### 2.9 Evaluate the fine-tuned MobileNet model (7 points)
"""

## Test the best model on the test set to evaluate its performance.
## Compute metrics such as accuracy, precision, recall, and F1-score to assess classification performance.
## Visualize confusion matrix to understand the model's behavior across different classes
## Comment on the results

# Import necessary libraries
from sklearn.metrics import classification_report, confusion_matrix
import seaborn as sns
import numpy as np
import matplotlib.pyplot as plt

# Load the best model
mobilenet_v2.load_state_dict(torch.load('/content/drive/MyDrive/MobileNetV2_v1.pth'))
mobilenet_v2.eval()

# Initialize variables to store predictions and labels
all_preds = []
all_labels = []

# Test the model
with torch.no_grad():
    for images, labels in test_loader:
        images, labels = images.to(device), labels.to(device)
        outputs = mobilenet_v2(images)
        _, predicted = outputs.max(1)
        all_preds.extend(predicted.cpu().numpy())
        all_labels.extend(labels.cpu().numpy())

# Convert predictions and labels to numpy arrays
all_preds = np.array(all_preds)
all_labels = np.array(all_labels)

# Compute accuracy
accuracy = np.mean(all_preds == all_labels)
print(f"Test Accuracy: {accuracy * 100:.2f}%")

# Compute precision, recall, and F1-score
class_names = test_dataset.classes  # Extract class names from the dataset
report = classification_report(all_labels, all_preds, target_names=class_names)
print("\nClassification Report:\n")
print(report)

# Generate confusion matrix
cm = confusion_matrix(all_labels, all_preds)

# Visualize confusion matrix
plt.figure(figsize=(10, 8))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=class_names, yticklabels=class_names)
plt.xlabel('Predicted')
plt.ylabel('True')
plt.title('Confusion Matrix')
plt.show()

"""The MobileNetV2 model performs very well for the test set, either by looking at the classification report or the confusion matrix. The overall accuracy equals 95%, while the macro and weighted averages of the precision, recall, and F1-score are also 95%. This means that MobileNetV2 has a powerful ability in correctly classifying instances among all classes. Most classes have over 90% precision, recall, and F1-score, which hints that the model has gained a good representation of the distinguishing features of each class, generalizing well to the unseen data.

The following confusion matrix shows a few misclassification points. For example, small confusion between "cane" and "cavallo" classes is observed by a few cases being misclassified between both classes. Such misclassifications might be due to similarities in visual features or poses in the dataset. Similarly, there are isolated cases where "mucca" and "pecora" overlap, which is expected given their visual resemblance. However, these errors are minimal and do not significantly impact the overall performance.

Notably, classes such as "farfalla," "ragno," and "pecora" have almost perfect precisions and recalls, showing that this model is highly confident with these classes. This could be due to the distinctive look of these animals, which is well utilized by the pre-trained weights and feature-extracting capabilities of the MobileNetV2 architecture.

In the end, the MobileNetV2 model performs the best in classifying the animal-10 dataset with only minor misclassifications. Its performance outperforms simpler models, thus pointing out the advantage of using pre-trained architectures for image classification tasks. The results prove the practical applicability of MobileNetV2, especially for those tasks that require high accuracy with efficient resource utilization.
"""

## Compare the best fine-tuned MobileNet model performance with the best CNN model implemented from scratch
## Compare the best fine-tuned MobileNet model performance with the best ResNet18 model implemented from scratch

"""It follows from the fine-tuning that was performed with MobileNetV2, ResNet18, and a custom CNN that the performance of pre-trained models far outpaces those built from scratch. The best test accuracy of 96.93% was obtained using ResNet18, showing its great capability of learning and generalizing on this dataset. In addition, residual connections applied in this model help to avoid the vanishing gradient problem and are very helpful in deeper layers for feature extraction. This made it effective across all classes, as the confusion matrix and classification report support, where most predictions are correct, with precision, recall, and F1-score near 97%.

MobileNetV2 also showed promising results, with a test accuracy of 95.33%. While it was a bit less accurate than ResNet18, its lightweight architecture, optimized for efficiency, makes it a strong candidate for real-world applications requiring lower computational resources, such as mobile devices. The slight drop in accuracy compared to ResNet18 might be because it focuses on efficiency over depth, which could limit its ability to fully capture some of the dataset's complexities.

In contrast, the accuracy of the CNN model implemented from scratch stands at a low of 65% during the test. This is probably because this network was not deep enough to capture features hierarchically from the dataset. Moreover, there is no transfer learning in that, which gives pre-trained models like ResNet18 and MobileNetV2 an important boost by leveraging knowledge from large datasets like ImageNet. The confusion matrix also showed the custom CNN making a large amount of misclassification across many classes, generally highlighting that it could not generalize effectively.

In practical terms, ResNet18 is a very good option when the task is related to high stakes, such as medical imaging or security applications, where high accuracy is necessary. MobileNetV2 is a bit less accurate but more suitable in an environment with limited computational resources, such as in mobile applications or embedded systems. The custom CNN model is useful for learning and experimenting with but is not competitive in tasks that require high accuracy and generalization.

This exercise, in conclusion, serves to illustrate the success of pre-trained models for the complex task of image classification and the need to select an appropriate architecture based on the trade-off between accuracy and computational efficiency.

### 2.10 Kaggle Test Result (5 points)
* Put your Kaggle test result for your MobileNet pretrained model here and comment on it.
* You will get a score between 0-1 and your percentage (e.g. 0.1, 0.3, 0.6, 0.85) of accuracy will be multiplied by the highest possible score (5 points) for this part. That will be your grading score.

The MobileNetV2 pre-trained model achieved an impressive accuracy of 94.5% on the Kaggle test dataset. This high score demonstrates the model's excellent generalization ability and its effectiveness in handling the classification task. The pre-trained weights of MobileNetV2, combined with its lightweight architecture, played a significant role in achieving this result, making it both computationally efficient and accurate.
"""

import os
import torch
import pandas as pd
from PIL import Image
from torch.utils.data import Dataset, DataLoader
import torchvision.transforms as transforms

# Define the directory containing the test images
test_dir = '/content/drive/MyDrive/Colab Notebooks/test-images2'

#  Get all test image paths and sort them numerically
sorted_files = sorted(
    [os.path.join(test_dir, f) for f in os.listdir(test_dir) if f.endswith(('jpg', 'jpeg', 'png'))],
    key=lambda x: int(''.join(filter(str.isdigit, os.path.basename(x))))
)

#  Define transformation for test images
transform = transforms.Compose([
    transforms.Resize((256, 256)),  # Resize images
    transforms.ToTensor(),  # Convert to tensor
    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])  # Normalize
])

#  Create a custom Dataset class for test images
class TestDataset(Dataset):
    def __init__(self, image_paths, transform):
        self.image_paths = image_paths
        self.transform = transform

    def __len__(self):
        return len(self.image_paths)

    def __getitem__(self, idx):
        img_path = self.image_paths[idx]
        img = Image.open(img_path).convert('RGB')  # Ensure RGB format
        img = self.transform(img)
        return img, os.path.basename(img_path).split('.')[0]  # Return image and its ID

test_dataset = TestDataset(image_paths=sorted_files, transform=transform)
test_loader = DataLoader(test_dataset, batch_size=32, shuffle=False)

#  Load the best model (e.g., MobileNetV2)
model = mobilenet_v2.to('cuda')  # Move model to GPU
model.load_state_dict(torch.load('/content/drive/MyDrive/MobileNetV2_v1.pth'))
model.eval()

# Predict on the test dataset and generate labels
kaggle_preds = []
image_ids = []

with torch.no_grad():
    for images, ids in test_loader:
        images = images.to('cuda')  # Move images to GPU
        outputs = model(images)  # Forward pass
        _, predicted = torch.max(outputs, 1)  # Get predicted class indices
        kaggle_preds.extend(predicted.cpu().numpy())  # Store predictions
        image_ids.extend(ids)  # Store image IDs

# Map predicted class indices to class names
class_names = ['cane', 'cavallo', 'elefante', 'farfalla', 'gallina', 'gatto', 'mucca', 'pecora', 'ragno', 'scoiattolo']  # Replace with your class names
predicted_labels = [class_names[pred] for pred in kaggle_preds]

# Create and save the submission CSV file
submission = pd.DataFrame({'ID': image_ids, 'Label': predicted_labels})
submission.to_csv('/content/predictions.csv', index=False)
print("Submission file saved as 'predictions.csv'")


from google.colab import files
files.download('/content/predictions.csv')

"""## 3 Analyze advantages and disadvantages (7 points)

* Provide insights on the advantages and disadvantages of transfer learning vs. training from scratch
* Put a table for comparison of the best 3 models that you have obtained in this assignment (CNN from scratch, ResNet18, MobileNet)
* Discuss practical considerations when choosing between these approaches and models.

![image.png](data:image/png;base64,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cjv9F1L5REAEREAEREAEREAEREAEREAEREAEREAEREAEup6ADLld/wgIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIQKcTkCG3038hlU8EREAEREAEREAEREAEREAEREAEREAEREAERKDrCciQ2/WPgACIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAh0OgEZcjv9F1L5REAEREAEREAEREAEREAEREAEREAEREAEREAEup6ADLld/wgIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIQKcTkCG3038hlU8EREAEREAEREAEREAEREAEREAEREAEREAERKDrCciQ2/WPgACIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAh0OgEZcjv9F1L5REAEREAEREAEREAEREAEREAEREAEREAEREAEup6ADLld/wgIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIQKcTkCG3038hlU8EREAEREAEREAEmiDwzTffhN/97nfhmWeeaSKX4lP/9re/heuuuy68++67xQm0VwREQAREQAREQAREQAREoGUExm5ZTspIBERABERABERABESg4whsueWW4Yknnojl2nfffcPw4cNbUsYvvvgiLL/88uHLL78MY445Zrj66qvDPPPM05K8+yuTxx9/PJxzzjnx8jPPPHM48MAD+6souq4IiEAVAs8++2w45ZRT8lRHH310mHLKKfPtww8/PLzxxhtxe9FFFw3bb799fqzeFemGeokpvQg0T+Cf//xnePvtt8M000wTxhtvvOYz7PIcLr300nDvvfdGCquuumpYd911u5zIwL19GXIH7m+nkotAVxM46aSTwgsvvNAQg7HHHjv86le/aujcgXASRgiMNg8//HAs7h577BG23nrrgVB0lVEE2k7gkEMOiQ17GuXIkksuWXLN8ccfP0wxxRSBRv9yyy0X0BcDWT788MPciMt93HLLLS0z5N53333RiEu+//3vf8Ntt902oA25eC7b88E9pXrzqquuCnfeeSeHoiy00EJhxx13tM2qSxpQMDNZfPHFwzbbbGObWopAzQTSZzE98fvf/36Yc845w09+8pMw99xzh8kmmyxNMii2P/300/DII4/k9/KPf/wjX2cFQ+/zzz8f90000UQlx+rZkG6oh5bSdgqBp59+Opx55pl1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NkOGDAmnnXZas1nqfBHoWgKffPJJ2HvvvcN//vOfMM4444STTz45jD/++H3O49Zbbw1XX311vO6iiy4att9++z4vgy4oAiIweAlIxwze31Z3JgLdQuCbb74Ju+++e/jiiy/CGGOMEY466qgw5ZRTdsvt6z5FQARqICA9UQMkJelKAm0x5B5yyCHhnXfeyYFuvPHGYfnll8+3q63sv//+4f3338+TDR8+PAwdOjTf7suVv/3tb+GRRx7JL/nll1/m661Yeeutt/L8J5100lZkqTxEoGsJ0Ony4IMPxvvfbrvtehlx//3vf4fLLrssPPDAA+G5554L8847b9Qtm2yySRhrrLGqcjvmmGPCq6++GsYee+xw/PHHhwknnLDwHPTV0UcfHT766KPw2GOPhWWXXTbMNddchWm1UwREoP8J3HPPPeHyyy8PH374YXjttdfCaqutFk488cT+L1iZEkjHlAGj3SLQxQTee++9cOCBB0YCDz/8cFhyySXDcccdFyabbLKOpPK9730vLLjggrGMFPDII48MZ511VkeWVYUSgcFEYNdddw1///vfA3oCB7WDDz44LLPMMh15i9ITHfmzqFAdQKAtoRWeeeaZqBhQDvxdeOGFNd/qSy+9FEaNGlVyvjfq1pyREoqACHQVgaeeeirccMMN8Z5ptGDITQXjKo0a9NLnn38eHnrooYBxFqNsNbnlllvCJZdcEs+db775yhpxyQcvYLxMkP/+97+Bzi2WEhEQgc4kcMUVV8R3GyMu8tvf/jYwIqdTRTqmU38ZlUsE+o/AzTffnLefKAV1nd/97nf9V6AarrzpppuG6aabLqa8++67w3333VfDWUoiAiLQKIE//vGPcTQw+gHB+e6qq65qNLs+OU96ok8w6yIDjEBbDLkpAwwso0ePTncXbl977bWF+7VTBERABMoRwNP2sMMOCz09PTHJmmuuGb7//e+XJL/99tvDlVdeGfftt99+4cknnwx77LFH3MZAi0deOcGzlrAqyNxzzx223Xbbcknz/auuumr44Q9/GLfx/rVQC3kCrYiACHQEgY8//jg8+uijvcqCUaSTRTqmk38dlU0E+p4AHVCp3HTTTemujtpmhNO6666blwmv3K+//jrf1ooIiEBrCRTVbRip+Nlnn7X2Qi3MTXqihTCV1aAh0CeGXGjVYqD95z//GTq9wjFofnnd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QAREQAQaJyBDbuPsdKYIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAI9AkBGXL7BLMuIgIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAKNE5Aht3F2OlMEREAEREAEREAEREAEREAEREAEREAEREAEREAE+oSADLl9glkXEQEREAEREAEREAEREAEREAEREAEREAEREAEREIHGCciQ2zg7nSkCIiACIiACIiACIiACIiACIiACIiACIiACIiACfUJAhtw+wayLiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiEDjBGTIbZydzhQBERABERABERABERABERABERABERABERABERCBPiEwxgMPPNDTJ1fSRURABERABERABERABERABERABERABERABERABERABBoiII/chrDpJBEQAREQAREQAREQAREQAREQAREQAREQAREQARHoOwJj9GTSd5fTlURABAYzgVdeeSXe3myzzTaYb1P3JgIi0EIC0hsthKmsREAE+oWA9Fi/YNdFRWBAEZCeGFA/lworAh1NQB65Hf3zqHAiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiEIIMuXoKREAEREAEREAEREAEREAEREAEREAEREAEREAERKDDCciQ2+E/kIonAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAjLk6hkQAREQAREQAREQAREQAREQAREQAREQAREQAREQgQ4nIENuh/9AKp4IiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIyJCrZ0AEREAEREAEREAEREAEREAEREAEREAEREAEREAEOpyADLkd/gOpeCIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgQ66eAREQAREQAREQAREQAREQAREQAREQAREQAREQARHocAIy5Hb4D6TiiYAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAMuXoGREAEREAEREAEREAEREAEREAEREAEREAEREAERKDDCciQ2+E/kIonAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAjLk6hkQAREQAREQAREQAREQAREQAREQAREQAREQAREQgQ4nIENuh/9AKp4IiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIyJCrZ0AEREAEREAEREAEREAEREAEREAEREAEREAEREAEOpyADLkd/gOpeCIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgQ66eAREQAREQAREQAREQAREQAREQAREQAREQAREQARHocAIy5Hb4D6TiiYAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAMuXoGREAEREAEREAEREAEREAEREAEREAEREAEREAERKDDCciQ2+E/kIonAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAjLk6hkQAREQAREQAREQAREQAREQAREQAREQAREQAREQgQ4n0KeG3J6envDee++FV155Jfz973/vcDTtLd65554bdtttt8ii6EqjR48OpNl2223DeuutF6655pqiZNonAiJQQODTTz8Nb7zxRvjvf/9bcLT/d3399dfh9ddfD3/961+bLsy///3vpvNQBiLQ7QT+8Y9/hFdffTV8+eWXbUHR6TqpLTetTEVABPqUwH/+859Y9/n444/bcl305GuvvRb++c9/tiV/ZSoCItA3BLDHvPPOOwHbTKuFdgltsM8++6zVWSs/ERABR2Bst96WVV7mG264IRol//jHP4Z//etf+XWmnXbasPbaa4ddd901TDLJJPn+dIU0VE6WXnrpsNdee6WHC7ePP/748NBDD4W55porHHPMMSVpMIpefvnlYcwxxwynn356oBzVBGW30047xWSHH354mG+++aqdUvb4H/7wh7DPPvvEPGaZZZZe6eC0xhprhL/97W/5sZlmmikadPMdWhEBESgh8MEHH4STTz45/OY3vwkYTZAf/vCHYf755w9rrbVW2GabbUrS17px9NFHh8ceeyxP/utf/zpMOumk+XY9K6NGjYq6kPys8jTNNNOEJZdcMhx55JHhxz/+cU3ZXXXVVeGBBx4I6JKXXnopTDnllFGfcK/c50QTTVRTPkokAt1O4Le//W3gHX/hhRfyd5LvLXWNDTfcMNYTGmXUiE56++23w84771zXJSebbLJwwQUX1HWOEouACAweAs8991w45JBDwu9///u8nTXxxBOHrbbaKraxqAs1KnQ8X3TRReHss88Ob731Vszme9/7XmxfDR06NBxwwAHhBz/4QdnscVrBOaUWoQ4388wz15JUaURABOok8NFHH0WbCG0I67Qeb7zxwqqrrhoOPfTQMN1009WZY2nyW265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eCP86U9/Sscvv/xyILTA008/Xc3/8MMPq58/+uijsN9++4XjjjsuVCqVavrjjz8edSXWygAAQABJREFUeF1wwQUBI+1ZZ50VppxyypT/7rvvVtvPFf75z38GXsh8882Xk6vv48aNC6uvvnp46623qmlsPgafK6+8MpxwwgmBeLvLLLNMNb/2Awy/+c1vhvfff7+ahYctL4zdV111VfUaqwX++2HRRRcNF110USr7n//8J0wwwYB83bWn9VgCEpCABCQgAQlIQAISkIAEJCABCUhAAhLoZwID4pGbjbgs7ccT9oknnkgesqeffnpYaqmlkmHz+9//ftqMq/Z+fv3rX1eNuGussUY46qijAp6zhx56aFhttdXC+OOPH84444zw3e9+t7Zq9XjrrbcOr732WuAdY+15550XVl111Wo+9Y899thkxN1www3TNd5zzz3hxhtvDHvuuWeYZJJJws033xy22267ap0555wzGUQxoM4000wpfc0116ymYZQtCsZaPIox4n7xi18MO++8czK6XnbZZWH06NHJO/eVV14J66yzTjJQF+vmz3gVb7LJJmHZZZcNxx9/fLj77ruTARgvZ+Svf/1rUw4YchGu4YEHHkif/SMBCUhAAhKQgAQkIAEJSEACEpCABCQgAQkMPwL97qJJuAAMjsjRRx+dwilkLHjgLr/88smoiqH17LPPDjvttFPODhdffHE48MAD0zHGYOpnITzDtttuG/bdd9/kzXvFFVckA/Fcc82Vi1Tf8cjFU3WRRRappuUPhG3Aq3eyySZL14ahebzxxsvZYYkllgjTTDNNMuhizM2erJNOOmlYeumlUzkMvcgXvvCFalpK+O+fTz75JBlxCasw+eSTB4y3X/7yl6tFCBPBfdMeRlZCUNQL/fDss8+ma8RrN3vT0g7hIgidcNpppyWDMx7GRe/kfKKFFloof6x6DlcT/CABCUhAAhKQgAQkIAEJSEACEpCABCQgAQkMGwL97pH70EMPVcMV4MVaK9NPP32gzEsvvdTFiEu53/3ud6n4/PPPH8aOHVtbNR1jyMVTd8kllwy33HJL3TI//vGP6xpxKYxH7+23357Of8opp3Qx4ubG8LRF/v3vfyev15xe9p3wEQ8//HAqTgiJohE3t0FMXsJD4KEMi2LohFyGdzyRsxG3mI5HM4IR95FHHilmVT9PNdVUYcIJ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gm4p/ZAwZsyY8MADD9Rtabzxxgtzzz13WGqppcKSSy4ZZp999rrl2pm44YYbBhTRCiusEPbYY49Sl3LIIYeEv/zlL2H++ecPBx10UKk6A1mIjta+++4bUNTjjz9+uPjii5ue7h//+Ec4++yzw3333Rfuv//+8M4774QFFlggLLbYYmHVVVcN66yzTtP6ZkqgnQQ+/vjjcNRRR4Xf//73gf9l5DOf+UzSNWuvvXbYa6+9wsQTT9zwEt97772w6aabNswvZkw66aThnHPOKSaV/swzdsstt6Rn7O9//3v44he/GBZeeOGwyCKLhO222y5MPfXULdu69dZbw+WXX56e1b/97W/pvnIb3AM6SJGABMoRuOKKK8KBBx4YHn744eqAZs4550y//TxP/H72RoaLTurNvVlHAhIYWgQefPDBwNjrz3/+c/joo4/SxU0zzTRh2223DT/+8Y/DFFNM0esLvuiii8Lxxx8f7rzzzqqOnHnmmcNyyy0XfvWrX4UZZpihadu77LJLtV/WtGDMPPTQQ8OXvvSlVsXMl4AEekHg1VdfTTYKxiJ50poxDeOk/fffP8w666y9aPX/q2A/OPzww8NVV11V1UGMaRjf/OxnPwtLLLFE07ZPPvnkcNlllzUtkzO/+93vhvXXXz8f+i6BEUtgvDgT079TMRHleuutF2666aZSUBkoHXPMMWGCCQbEplzqGmoL0fnBWw6j8yWXXBK++tWv1hbpdvyd73wnGUuXXXbZcO2113bL70sCRtVsHP7Wt76VDD/N2oP9D37wg/DSSy+lYgxE33zzzYZVrrvuurDNNtuEt956q2GZ733vewFj9YQTTtiwjBkSwBMWmWeeeQYNxocffhi23HLLcM011zQ8J5MSJ510UpqcqFcI4y+djTIy+eSTh3/+859lilbL4O23ww47BAZEjWSOOeYI5557bph33nkbFQlHHHFEGqx9+umndctMNtlk4YQTTgjf/OY36+abKIGhSKAdegMOu+++e3peMhN+84tdonXXXTdNDjEp1BMZDjqpJ/djWQlIoDWBdukx+hX04XO/oFaPMTFFP//zn/9865uoKfHb3/42/OIXv6hJ/d8h46UjjzyyaZ+DPg1OJWUEQ3TZvliZ9iwjgaFGoF16ghVHq6++eheP+qKuwKB76aWXhmWWWabHyLA7fPvb3264EhIbD45xvBrZ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rxJ+P5A4aRjiRGX6XPbPcNFJZe/HchKQwNAlwArG7bbbLvWZWZl2ySWXpD4GYWII8zbxxBMHPNo22mijECelenQjBx10UPjFL36R6rD67Xe/+10KW/XXv/41rYCKTivhjTfeCFtssUW49dZbe9Q24eeo29e+VY9OamEJjFACjCMYf2A7iMbbcOSRR4ZnnnkmjZVOP/305JVLeCnGUE8//XSPKBFGkrE69VkJefDBB4e77rorhXhhXP61r30t6R70SU9X56Jz6JtNOumkydO3RxdmYQmMBAIDYaUueuQyIxPd4EufJj7kXWZehqpHbrMbGgyP3J1kiCQAAB7mSURBVDzTddJJJzW7lJQ3kB655513XvX7wpO2niy00EKpzNZbb10vu1taNNCm8vwfFQWP3thRrebFH41idvocO6+VWWedNZXpjTd4twZN6BGBwZ5pjoOM9F3zPERDad1r/ctf/lKdKcZ7vKxkb7355puvEicMqufpqUcu/5Mrrrhitf6Pf/zjSlzumI6beeTmWei111678s4773S7bGa2oxE7tcMzHuNSdStjggSGA4HB1htxcrkSBxzp2eF3pt6zg9cHemWqqaaq8AyXleGgk8rei+UkIIHyBAZbj3FluZ9A37h2dSD5MdRb0mPosjgBTFIpKa5GWnPNNSvRQaJbPVYFxjA0qX36OGVXBuX+FLr1jjvuqF4f16pIoNMJtENPFMccf/7zn7sh/vvf/15hNSt64vvf/363/EYJb731VrUeto8nnniiW1HGKqxuom3O8c9//rNbmXoJ0dBcbfvYY4+tRINwamP06NH1ipsmgRFJYMA9cjGGE4820m1pF8cL85RTTmlZzgL/I7D33nuHqDj/lzAEP2XvpquuuqrlRjJ4DuARhWRv3nxLscMX4nKsdEh83EkmmSRnVd/xSCCWF3LDDTeU+r+rVvbDsCKAvmAmGcFbJIYOqXv9xL/MXiV44BFztpXwv3biiSemYsRjYga7t4K3LJ77cWlRirt52GGHpdll2htvvPHqNkusKjZURPbYY48wxRRTdCs3wQQThM033zylE7c3PzfdCpogAQl0IYAeiJMjadUHnims/qiVuKQ4efOzcQex8MvIcNFJZe7FMhKQwNAmQB8BbzWEPk691YH0v1daaaVUBp1WVvCkQ/DojQ4b1T5LsT6xMM8888yURB+Hcq0E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)

Two methods prominent in deep learning are transfer learning and training from scratch; each has its unique set of advantages and disadvantages. In this problem, transfer learning would employ models such as ResNet18 and MobileNetV2 that have been previously trained on vast amounts of data using datasets like ImageNet. These approaches will save enormous time in training and significant computation because the model already has knowledge of how to extract useful features from the image. For instance, in this work, ResNet18 performed the best with an accuracy of 96.93%, outperforming others in precision, recall, and F1-score. It was closely followed by MobileNetV2, which had an accuracy of 95.33%. This model is very lightweight and, therefore, can be used in environments where computational power is limited, such as mobile or embedded systems. These models excel because they benefit from their robust feature extraction capabilities honed during their extensive pre-training on diverse datasets.

In contrast, although training a CNN from scratch offers the most flexibility and allows customization for specific datasets, it is very resource-intensive and less effective when the dataset is small. This assignment achieved a significantly lower accuracy of 65% with the CNN model trained from scratch, struggling to generalize and classify images effectively. This is because training from scratch requires a larger dataset and longer training time to learn useful features, as the model starts with random weights and no prior knowledge. Despite its disadvantages, training a model from scratch provides valuable insights into the fundamentals of deep learning, making it a good learning exercise for students.

The decision of using transfer learning or training from scratch in practice depends on a lot of factors like dataset size, computational resources, and application requirements. For example, if the need for high accuracy and reliability exists, and if computational resources are sufficient, ResNet18 can be one of the best choices since it has a deep architecture with well-established performance. For applications that demand lightweight and efficient models, like mobile or edge devices, MobileNetV2 strikes a good balance between accuracy and efficiency. However, if the dataset is highly unique and deviates significantly from pre-trained datasets like ImageNet, it may be necessary to train from scratch, although this will require more computational resources and larger datasets. Ultimately, transfer learning is often the preferred approach in real-world scenarios due to its ability to deliver high performance with minimal training time and resources.
"""